// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: keymap/v1/validation.proto

package keymapv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ValidationReport is the overall report of a validation run.
type ValidationReport struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The source editor of the validation run.
	SourceEditor string `protobuf:"bytes,1,opt,name=source_editor,json=sourceEditor,proto3" json:"source_editor,omitempty"`
	// The summary of the validation run.
	Summary *Summary `protobuf:"bytes,2,opt,name=summary,proto3" json:"summary,omitempty"`
	// The issues detected during the validation run.
	Issues []*ValidationIssue `protobuf:"bytes,3,rep,name=issues,proto3" json:"issues,omitempty"`
	// The warnings issued during the validation run.
	// Warnings are just issues that tend to not harm
	Warnings      []*ValidationIssue `protobuf:"bytes,4,rep,name=warnings,proto3" json:"warnings,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidationReport) Reset() {
	*x = ValidationReport{}
	mi := &file_keymap_v1_validation_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidationReport) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidationReport) ProtoMessage() {}

func (x *ValidationReport) ProtoReflect() protoreflect.Message {
	mi := &file_keymap_v1_validation_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidationReport.ProtoReflect.Descriptor instead.
func (*ValidationReport) Descriptor() ([]byte, []int) {
	return file_keymap_v1_validation_proto_rawDescGZIP(), []int{0}
}

func (x *ValidationReport) GetSourceEditor() string {
	if x != nil {
		return x.SourceEditor
	}
	return ""
}

func (x *ValidationReport) GetSummary() *Summary {
	if x != nil {
		return x.Summary
	}
	return nil
}

func (x *ValidationReport) GetIssues() []*ValidationIssue {
	if x != nil {
		return x.Issues
	}
	return nil
}

func (x *ValidationReport) GetWarnings() []*ValidationIssue {
	if x != nil {
		return x.Warnings
	}
	return nil
}

// Summary is the summary of a validation run.
type Summary struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The total number of mappings processed.
	MappingsProcessed int32 `protobuf:"varint,1,opt,name=mappings_processed,json=mappingsProcessed,proto3" json:"mappings_processed,omitempty"`
	// The number of mappings that succeeded.
	MappingsSucceeded int32 `protobuf:"varint,2,opt,name=mappings_succeeded,json=mappingsSucceeded,proto3" json:"mappings_succeeded,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *Summary) Reset() {
	*x = Summary{}
	mi := &file_keymap_v1_validation_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Summary) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Summary) ProtoMessage() {}

func (x *Summary) ProtoReflect() protoreflect.Message {
	mi := &file_keymap_v1_validation_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Summary.ProtoReflect.Descriptor instead.
func (*Summary) Descriptor() ([]byte, []int) {
	return file_keymap_v1_validation_proto_rawDescGZIP(), []int{1}
}

func (x *Summary) GetMappingsProcessed() int32 {
	if x != nil {
		return x.MappingsProcessed
	}
	return 0
}

func (x *Summary) GetMappingsSucceeded() int32 {
	if x != nil {
		return x.MappingsSucceeded
	}
	return 0
}

// ValidationIssue is a single issue detected during validation.
type ValidationIssue struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Issue:
	//
	//	*ValidationIssue_KeybindConflict
	//	*ValidationIssue_DanglingAction
	//	*ValidationIssue_UnsupportedAction
	//	*ValidationIssue_DuplicateMapping
	//	*ValidationIssue_PotentialShadowing
	Issue         isValidationIssue_Issue `protobuf_oneof:"issue"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidationIssue) Reset() {
	*x = ValidationIssue{}
	mi := &file_keymap_v1_validation_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidationIssue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidationIssue) ProtoMessage() {}

func (x *ValidationIssue) ProtoReflect() protoreflect.Message {
	mi := &file_keymap_v1_validation_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidationIssue.ProtoReflect.Descriptor instead.
func (*ValidationIssue) Descriptor() ([]byte, []int) {
	return file_keymap_v1_validation_proto_rawDescGZIP(), []int{2}
}

func (x *ValidationIssue) GetIssue() isValidationIssue_Issue {
	if x != nil {
		return x.Issue
	}
	return nil
}

func (x *ValidationIssue) GetKeybindConflict() *KeybindConflict {
	if x != nil {
		if x, ok := x.Issue.(*ValidationIssue_KeybindConflict); ok {
			return x.KeybindConflict
		}
	}
	return nil
}

func (x *ValidationIssue) GetDanglingAction() *DanglingAction {
	if x != nil {
		if x, ok := x.Issue.(*ValidationIssue_DanglingAction); ok {
			return x.DanglingAction
		}
	}
	return nil
}

func (x *ValidationIssue) GetUnsupportedAction() *UnsupportedAction {
	if x != nil {
		if x, ok := x.Issue.(*ValidationIssue_UnsupportedAction); ok {
			return x.UnsupportedAction
		}
	}
	return nil
}

func (x *ValidationIssue) GetDuplicateMapping() *DuplicateMapping {
	if x != nil {
		if x, ok := x.Issue.(*ValidationIssue_DuplicateMapping); ok {
			return x.DuplicateMapping
		}
	}
	return nil
}

func (x *ValidationIssue) GetPotentialShadowing() *PotentialShadowing {
	if x != nil {
		if x, ok := x.Issue.(*ValidationIssue_PotentialShadowing); ok {
			return x.PotentialShadowing
		}
	}
	return nil
}

type isValidationIssue_Issue interface {
	isValidationIssue_Issue()
}

type ValidationIssue_KeybindConflict struct {
	// KeybindConflict is that multiple actions are mapped to the same keybinding.
	KeybindConflict *KeybindConflict `protobuf:"bytes,1,opt,name=keybind_conflict,json=keybindConflict,proto3,oneof"`
}

type ValidationIssue_DanglingAction struct {
	// DanglingAction is that an action is mapped to a keybinding that does not exist.
	DanglingAction *DanglingAction `protobuf:"bytes,2,opt,name=dangling_action,json=danglingAction,proto3,oneof"`
}

type ValidationIssue_UnsupportedAction struct {
	// UnsupportedAction is that an action is mapped to a keybinding that is not supported by the target editor.
	UnsupportedAction *UnsupportedAction `protobuf:"bytes,3,opt,name=unsupported_action,json=unsupportedAction,proto3,oneof"`
}

type ValidationIssue_DuplicateMapping struct {
	// DuplicateMapping is that the same action and keybinding combination appears multiple times.
	DuplicateMapping *DuplicateMapping `protobuf:"bytes,4,opt,name=duplicate_mapping,json=duplicateMapping,proto3,oneof"`
}

type ValidationIssue_PotentialShadowing struct {
	// PotentialShadowing is that a keybinding might shadow a critical system shortcut.
	PotentialShadowing *PotentialShadowing `protobuf:"bytes,5,opt,name=potential_shadowing,json=potentialShadowing,proto3,oneof"`
}

func (*ValidationIssue_KeybindConflict) isValidationIssue_Issue() {}

func (*ValidationIssue_DanglingAction) isValidationIssue_Issue() {}

func (*ValidationIssue_UnsupportedAction) isValidationIssue_Issue() {}

func (*ValidationIssue_DuplicateMapping) isValidationIssue_Issue() {}

func (*ValidationIssue_PotentialShadowing) isValidationIssue_Issue() {}

// KeybindConflict is a keybinding conflict detected during validation.
type KeybindConflict struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The keybinding that is in conflict.
	Keybinding string `protobuf:"bytes,1,opt,name=keybinding,proto3" json:"keybinding,omitempty"`
	// The actions that are in conflict.
	Actions       []*KeybindConflict_Action `protobuf:"bytes,2,rep,name=actions,proto3" json:"actions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeybindConflict) Reset() {
	*x = KeybindConflict{}
	mi := &file_keymap_v1_validation_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeybindConflict) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeybindConflict) ProtoMessage() {}

func (x *KeybindConflict) ProtoReflect() protoreflect.Message {
	mi := &file_keymap_v1_validation_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeybindConflict.ProtoReflect.Descriptor instead.
func (*KeybindConflict) Descriptor() ([]byte, []int) {
	return file_keymap_v1_validation_proto_rawDescGZIP(), []int{3}
}

func (x *KeybindConflict) GetKeybinding() string {
	if x != nil {
		return x.Keybinding
	}
	return ""
}

func (x *KeybindConflict) GetActions() []*KeybindConflict_Action {
	if x != nil {
		return x.Actions
	}
	return nil
}

// DanglingAction is a dangling action detected during validation.
type DanglingAction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The action that is dangling.
	Action string `protobuf:"bytes,1,opt,name=action,proto3" json:"action,omitempty"`
	// The keybinding that is dangling.
	Keybinding string `protobuf:"bytes,2,opt,name=keybinding,proto3" json:"keybinding,omitempty"`
	// The suggestion for the dangling action.
	Suggestion    string `protobuf:"bytes,3,opt,name=suggestion,proto3" json:"suggestion,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DanglingAction) Reset() {
	*x = DanglingAction{}
	mi := &file_keymap_v1_validation_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DanglingAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DanglingAction) ProtoMessage() {}

func (x *DanglingAction) ProtoReflect() protoreflect.Message {
	mi := &file_keymap_v1_validation_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DanglingAction.ProtoReflect.Descriptor instead.
func (*DanglingAction) Descriptor() ([]byte, []int) {
	return file_keymap_v1_validation_proto_rawDescGZIP(), []int{4}
}

func (x *DanglingAction) GetAction() string {
	if x != nil {
		return x.Action
	}
	return ""
}

func (x *DanglingAction) GetKeybinding() string {
	if x != nil {
		return x.Keybinding
	}
	return ""
}

func (x *DanglingAction) GetSuggestion() string {
	if x != nil {
		return x.Suggestion
	}
	return ""
}

// UnsupportedAction is an unsupported action detected during validation.
type UnsupportedAction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The action that is unsupported.
	Action string `protobuf:"bytes,1,opt,name=action,proto3" json:"action,omitempty"`
	// The keybinding that is unsupported.
	Keybinding string `protobuf:"bytes,2,opt,name=keybinding,proto3" json:"keybinding,omitempty"`
	// The target editor that the action is unsupported for.
	TargetEditor  string `protobuf:"bytes,3,opt,name=target_editor,json=targetEditor,proto3" json:"target_editor,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnsupportedAction) Reset() {
	*x = UnsupportedAction{}
	mi := &file_keymap_v1_validation_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnsupportedAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnsupportedAction) ProtoMessage() {}

func (x *UnsupportedAction) ProtoReflect() protoreflect.Message {
	mi := &file_keymap_v1_validation_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnsupportedAction.ProtoReflect.Descriptor instead.
func (*UnsupportedAction) Descriptor() ([]byte, []int) {
	return file_keymap_v1_validation_proto_rawDescGZIP(), []int{5}
}

func (x *UnsupportedAction) GetAction() string {
	if x != nil {
		return x.Action
	}
	return ""
}

func (x *UnsupportedAction) GetKeybinding() string {
	if x != nil {
		return x.Keybinding
	}
	return ""
}

func (x *UnsupportedAction) GetTargetEditor() string {
	if x != nil {
		return x.TargetEditor
	}
	return ""
}

// DuplicateMapping is a duplicate mapping detected during validation.
type DuplicateMapping struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The action that has duplicate mappings.
	Action string `protobuf:"bytes,1,opt,name=action,proto3" json:"action,omitempty"`
	// The keybinding that is duplicated.
	Keybinding string `protobuf:"bytes,2,opt,name=keybinding,proto3" json:"keybinding,omitempty"`
	// A message describing the issue.
	Message       string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DuplicateMapping) Reset() {
	*x = DuplicateMapping{}
	mi := &file_keymap_v1_validation_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DuplicateMapping) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DuplicateMapping) ProtoMessage() {}

func (x *DuplicateMapping) ProtoReflect() protoreflect.Message {
	mi := &file_keymap_v1_validation_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DuplicateMapping.ProtoReflect.Descriptor instead.
func (*DuplicateMapping) Descriptor() ([]byte, []int) {
	return file_keymap_v1_validation_proto_rawDescGZIP(), []int{6}
}

func (x *DuplicateMapping) GetAction() string {
	if x != nil {
		return x.Action
	}
	return ""
}

func (x *DuplicateMapping) GetKeybinding() string {
	if x != nil {
		return x.Keybinding
	}
	return ""
}

func (x *DuplicateMapping) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// PotentialShadowing is a keybinding that might shadow a critical system shortcut.
type PotentialShadowing struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The keybinding that might cause shadowing.
	Keybinding string `protobuf:"bytes,1,opt,name=keybinding,proto3" json:"keybinding,omitempty"`
	// The action mapped to this keybinding.
	Action string `protobuf:"bytes,2,opt,name=action,proto3" json:"action,omitempty"`
	// The target editor where shadowing might occur.
	TargetEditor string `protobuf:"bytes,3,opt,name=target_editor,json=targetEditor,proto3" json:"target_editor,omitempty"`
	// A message describing the potential issue.
	Message       string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PotentialShadowing) Reset() {
	*x = PotentialShadowing{}
	mi := &file_keymap_v1_validation_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PotentialShadowing) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PotentialShadowing) ProtoMessage() {}

func (x *PotentialShadowing) ProtoReflect() protoreflect.Message {
	mi := &file_keymap_v1_validation_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PotentialShadowing.ProtoReflect.Descriptor instead.
func (*PotentialShadowing) Descriptor() ([]byte, []int) {
	return file_keymap_v1_validation_proto_rawDescGZIP(), []int{7}
}

func (x *PotentialShadowing) GetKeybinding() string {
	if x != nil {
		return x.Keybinding
	}
	return ""
}

func (x *PotentialShadowing) GetAction() string {
	if x != nil {
		return x.Action
	}
	return ""
}

func (x *PotentialShadowing) GetTargetEditor() string {
	if x != nil {
		return x.TargetEditor
	}
	return ""
}

func (x *PotentialShadowing) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// Action is an action mapped to a editor command.
type KeybindConflict_Action struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The action identifier.
	Action string `protobuf:"bytes,1,opt,name=action,proto3" json:"action,omitempty"`
	// The editor command.
	EditorCommand string `protobuf:"bytes,2,opt,name=editor_command,json=editorCommand,proto3" json:"editor_command,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeybindConflict_Action) Reset() {
	*x = KeybindConflict_Action{}
	mi := &file_keymap_v1_validation_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeybindConflict_Action) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeybindConflict_Action) ProtoMessage() {}

func (x *KeybindConflict_Action) ProtoReflect() protoreflect.Message {
	mi := &file_keymap_v1_validation_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeybindConflict_Action.ProtoReflect.Descriptor instead.
func (*KeybindConflict_Action) Descriptor() ([]byte, []int) {
	return file_keymap_v1_validation_proto_rawDescGZIP(), []int{3, 0}
}

func (x *KeybindConflict_Action) GetAction() string {
	if x != nil {
		return x.Action
	}
	return ""
}

func (x *KeybindConflict_Action) GetEditorCommand() string {
	if x != nil {
		return x.EditorCommand
	}
	return ""
}

var File_keymap_v1_validation_proto protoreflect.FileDescriptor

const file_keymap_v1_validation_proto_rawDesc = "" +
	"\n" +
	"\x1akeymap/v1/validation.proto\x12\tkeymap.v1\"\xd1\x01\n" +
	"\x10ValidationReport\x12#\n" +
	"\rsource_editor\x18\x01 \x01(\tR\fsourceEditor\x12,\n" +
	"\asummary\x18\x02 \x01(\v2\x12.keymap.v1.SummaryR\asummary\x122\n" +
	"\x06issues\x18\x03 \x03(\v2\x1a.keymap.v1.ValidationIssueR\x06issues\x126\n" +
	"\bwarnings\x18\x04 \x03(\v2\x1a.keymap.v1.ValidationIssueR\bwarnings\"g\n" +
	"\aSummary\x12-\n" +
	"\x12mappings_processed\x18\x01 \x01(\x05R\x11mappingsProcessed\x12-\n" +
	"\x12mappings_succeeded\x18\x02 \x01(\x05R\x11mappingsSucceeded\"\x96\x03\n" +
	"\x0fValidationIssue\x12G\n" +
	"\x10keybind_conflict\x18\x01 \x01(\v2\x1a.keymap.v1.KeybindConflictH\x00R\x0fkeybindConflict\x12D\n" +
	"\x0fdangling_action\x18\x02 \x01(\v2\x19.keymap.v1.DanglingActionH\x00R\x0edanglingAction\x12M\n" +
	"\x12unsupported_action\x18\x03 \x01(\v2\x1c.keymap.v1.UnsupportedActionH\x00R\x11unsupportedAction\x12J\n" +
	"\x11duplicate_mapping\x18\x04 \x01(\v2\x1b.keymap.v1.DuplicateMappingH\x00R\x10duplicateMapping\x12P\n" +
	"\x13potential_shadowing\x18\x05 \x01(\v2\x1d.keymap.v1.PotentialShadowingH\x00R\x12potentialShadowingB\a\n" +
	"\x05issue\"\xb7\x01\n" +
	"\x0fKeybindConflict\x12\x1e\n" +
	"\n" +
	"keybinding\x18\x01 \x01(\tR\n" +
	"keybinding\x12;\n" +
	"\aactions\x18\x02 \x03(\v2!.keymap.v1.KeybindConflict.ActionR\aactions\x1aG\n" +
	"\x06Action\x12\x16\n" +
	"\x06action\x18\x01 \x01(\tR\x06action\x12%\n" +
	"\x0eeditor_command\x18\x02 \x01(\tR\reditorCommand\"h\n" +
	"\x0eDanglingAction\x12\x16\n" +
	"\x06action\x18\x01 \x01(\tR\x06action\x12\x1e\n" +
	"\n" +
	"keybinding\x18\x02 \x01(\tR\n" +
	"keybinding\x12\x1e\n" +
	"\n" +
	"suggestion\x18\x03 \x01(\tR\n" +
	"suggestion\"p\n" +
	"\x11UnsupportedAction\x12\x16\n" +
	"\x06action\x18\x01 \x01(\tR\x06action\x12\x1e\n" +
	"\n" +
	"keybinding\x18\x02 \x01(\tR\n" +
	"keybinding\x12#\n" +
	"\rtarget_editor\x18\x03 \x01(\tR\ftargetEditor\"d\n" +
	"\x10DuplicateMapping\x12\x16\n" +
	"\x06action\x18\x01 \x01(\tR\x06action\x12\x1e\n" +
	"\n" +
	"keybinding\x18\x02 \x01(\tR\n" +
	"keybinding\x12\x18\n" +
	"\amessage\x18\x03 \x01(\tR\amessage\"\x8b\x01\n" +
	"\x12PotentialShadowing\x12\x1e\n" +
	"\n" +
	"keybinding\x18\x01 \x01(\tR\n" +
	"keybinding\x12\x16\n" +
	"\x06action\x18\x02 \x01(\tR\x06action\x12#\n" +
	"\rtarget_editor\x18\x03 \x01(\tR\ftargetEditor\x12\x18\n" +
	"\amessage\x18\x04 \x01(\tR\amessageB\xa0\x01\n" +
	"\rcom.keymap.v1B\x0fValidationProtoP\x01Z9github.com/xinnjie/watchbeats/protogen/keymap/v1;keymapv1\xa2\x02\x03KXX\xaa\x02\tKeymap.V1\xca\x02\tKeymap\\V1\xe2\x02\x15Keymap\\V1\\GPBMetadata\xea\x02\n" +
	"Keymap::V1b\x06proto3"

var (
	file_keymap_v1_validation_proto_rawDescOnce sync.Once
	file_keymap_v1_validation_proto_rawDescData []byte
)

func file_keymap_v1_validation_proto_rawDescGZIP() []byte {
	file_keymap_v1_validation_proto_rawDescOnce.Do(func() {
		file_keymap_v1_validation_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_keymap_v1_validation_proto_rawDesc), len(file_keymap_v1_validation_proto_rawDesc)))
	})
	return file_keymap_v1_validation_proto_rawDescData
}

var file_keymap_v1_validation_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_keymap_v1_validation_proto_goTypes = []any{
	(*ValidationReport)(nil),       // 0: keymap.v1.ValidationReport
	(*Summary)(nil),                // 1: keymap.v1.Summary
	(*ValidationIssue)(nil),        // 2: keymap.v1.ValidationIssue
	(*KeybindConflict)(nil),        // 3: keymap.v1.KeybindConflict
	(*DanglingAction)(nil),         // 4: keymap.v1.DanglingAction
	(*UnsupportedAction)(nil),      // 5: keymap.v1.UnsupportedAction
	(*DuplicateMapping)(nil),       // 6: keymap.v1.DuplicateMapping
	(*PotentialShadowing)(nil),     // 7: keymap.v1.PotentialShadowing
	(*KeybindConflict_Action)(nil), // 8: keymap.v1.KeybindConflict.Action
}
var file_keymap_v1_validation_proto_depIdxs = []int32{
	1, // 0: keymap.v1.ValidationReport.summary:type_name -> keymap.v1.Summary
	2, // 1: keymap.v1.ValidationReport.issues:type_name -> keymap.v1.ValidationIssue
	2, // 2: keymap.v1.ValidationReport.warnings:type_name -> keymap.v1.ValidationIssue
	3, // 3: keymap.v1.ValidationIssue.keybind_conflict:type_name -> keymap.v1.KeybindConflict
	4, // 4: keymap.v1.ValidationIssue.dangling_action:type_name -> keymap.v1.DanglingAction
	5, // 5: keymap.v1.ValidationIssue.unsupported_action:type_name -> keymap.v1.UnsupportedAction
	6, // 6: keymap.v1.ValidationIssue.duplicate_mapping:type_name -> keymap.v1.DuplicateMapping
	7, // 7: keymap.v1.ValidationIssue.potential_shadowing:type_name -> keymap.v1.PotentialShadowing
	8, // 8: keymap.v1.KeybindConflict.actions:type_name -> keymap.v1.KeybindConflict.Action
	9, // [9:9] is the sub-list for method output_type
	9, // [9:9] is the sub-list for method input_type
	9, // [9:9] is the sub-list for extension type_name
	9, // [9:9] is the sub-list for extension extendee
	0, // [0:9] is the sub-list for field type_name
}

func init() { file_keymap_v1_validation_proto_init() }
func file_keymap_v1_validation_proto_init() {
	if File_keymap_v1_validation_proto != nil {
		return
	}
	file_keymap_v1_validation_proto_msgTypes[2].OneofWrappers = []any{
		(*ValidationIssue_KeybindConflict)(nil),
		(*ValidationIssue_DanglingAction)(nil),
		(*ValidationIssue_UnsupportedAction)(nil),
		(*ValidationIssue_DuplicateMapping)(nil),
		(*ValidationIssue_PotentialShadowing)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_keymap_v1_validation_proto_rawDesc), len(file_keymap_v1_validation_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_keymap_v1_validation_proto_goTypes,
		DependencyIndexes: file_keymap_v1_validation_proto_depIdxs,
		MessageInfos:      file_keymap_v1_validation_proto_msgTypes,
	}.Build()
	File_keymap_v1_validation_proto = out.File
	file_keymap_v1_validation_proto_goTypes = nil
	file_keymap_v1_validation_proto_depIdxs = nil
}
